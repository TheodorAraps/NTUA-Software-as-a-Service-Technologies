{"ast":null,"code":"import e from \"axios\";\nimport t from \"js-cookie\";\nconst r = {\n  user: {},\n  tokens: {},\n  mode: \"live\"\n};\n\nfunction n(e) {\n  try {\n    const t = e.split(\".\")[1].replace(\"-\", \"+\").replace(\"_\", \"/\");\n    return JSON.parse(atob(t));\n  } catch (e) {\n    console.error(\"Problem decoding JWT payload\", e);\n  }\n}\n\nfunction o(e) {\n  var t, r;\n\n  if (e) {\n    if (\"string\" == typeof e) throw new Error(e);\n    if (null != e && null != (t = e.response) && null != (r = t.data) && r.message) throw new Error(e.response.data.message);\n    throw e;\n  }\n}\n\nconst i = r.user;\n\nfunction s(e) {\n  return e.replace(/([^:]\\/)\\/+/g, \"$1\");\n}\n\nconst a = function (t, n, o) {\n  try {\n    const i = s(`${r.baseUrl}${t}`);\n    return Promise.resolve(e.put(i, n, o));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n},\n      c = function (t, n, o) {\n  try {\n    const i = s(`${r.baseUrl}${t}`);\n    return Promise.resolve(e.post(i, n, o));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n},\n      u = function (t, n) {\n  try {\n    const o = s(`${r.baseUrl}${t}`);\n    return Promise.resolve(e.get(o, n));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nfunction d(e, n, o) {\n  const i = `${o}.${r.tenantId}`;\n  n = n || {\n    secure: \"live\" === r.mode,\n    sameSite: \"Lax\"\n  }, \"refresh\" === o && (n.sameSite = \"Strict\"), t.set(i, e, n);\n}\n\nfunction h(e) {\n  let r, n;\n\n  try {\n    const e = window.location.pathname,\n          t = window.location.hostname,\n          o = t.split(\".\").slice(-2).join(\".\");\n    r = [void 0, e, \"/\"], n = [void 0, t, \".\" + t, o, \".\" + o];\n  } catch (e) {\n    r = [void 0, \"/\"], n = [void 0];\n  }\n\n  r.map(r => {\n    n.map(n => {\n      const o = {};\n      n && (o.domain = n), r && (o.path = r), t.remove(e, o);\n    });\n  });\n}\n\nfunction l() {\n  h(r.tokens.accessTokenName), h(r.tokens.idTokenName), h(r.tokens.refreshTokenName), r.tokens.accessToken = void 0, r.tokens.idToken = void 0, r.tokens.refreshToken = void 0, function () {\n    for (const e in r.user) \"function\" != typeof r.user[e] && delete r.user[e];\n  }();\n}\n\nfunction m(e) {\n  d(e.access.value, e.access.cookieOptions, \"access\"), d(e.id.value, e.id.cookieOptions, \"id\"), e.refresh && e.refresh.value && d(e.refresh.value, e.refresh.cookieOptions, \"refresh\"), v();\n}\n\nfunction f(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n\n  return r && r.then ? r.then(void 0, t) : r;\n}\n\nconst p = function (_ref) {\n  let {} = _ref;\n  return Promise.resolve();\n},\n      w = function () {\n  try {\n    const e = f(function () {\n      return Promise.resolve(function () {\n        try {\n          const e = t.get(r.tokens.refreshTokenName);\n          return Promise.resolve(f(function () {\n            return Promise.resolve(u(\"/auth/refresh\", {\n              headers: {\n                authorization: \"Bearer \" + e\n              }\n            })).then(function (_ref2) {\n              let {\n                data: e,\n                status: t\n              } = _ref2;\n              if (200 !== t) throw new Error(e.message || \"Problem with request\");\n              if (e.tokens) return m(e.tokens), e;\n              throw new Error(\"Problem setting cookies\");\n            });\n          }, function (e) {\n            o(e);\n          }));\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }()).then(function () {});\n    }, function (e) {\n      console.warn(\"Refresh failed: \" + e.message);\n    });\n    return Promise.resolve(e && e.then ? e.then(function () {}) : void 0);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nfunction v() {\n  [\"access\", \"id\", \"refresh\"].map(e => {\n    try {\n      const o = t.get(r.tokens[e + \"TokenName\"]);\n      r.tokens[e + \"Token\"] = o, \"id\" === e && o && function () {\n        if (!r.tokens.idToken) return console.warn(\"Cannot define user: missing ID token\");\n        r.user = r.user || {};\n        const e = n(r.tokens.idToken),\n              t = [\"email\", \"phoneNumber\", \"username\", \"name\", \"image\", \"data\", \"confirmedAt\", \"createdAt\", \"updatedAt\", \"mode\", \"userId\", \"userUuid\", \"tenantId\", \"isConfirmed\"];\n\n        for (const n of t) {\n          if (\"update\" === n) return;\n          r.user[n] = e[n];\n        }\n      }();\n    } catch (t) {\n      console.warn(`Problem setting ${e} token.`);\n    }\n  });\n}\n\nr.tokens = r.tokens || {}, r.tokens.refresh = w;\nconst k = r.tokens;\n\nfunction P(e) {\n  if (\"object\" == typeof window && \"object\" == typeof window.location && window.location.href && !(window.location.href.indexOf(e + \"=\") < 0)) return decodeURIComponent(window.location.href.split(e + \"=\")[1].split(\"&\")[0]);\n}\n\nconst y = _ref3 => {\n  let {\n    redirect: e,\n    data: t\n  } = _ref3;\n  !1 !== e && g(e || P(\"redirect\") || t.redirectTo || \"/\");\n};\n\nfunction g(e) {\n  if (!e || \"object\" != typeof document || \"object\" != typeof window) return;\n\n  try {\n    document && window;\n  } catch (e) {\n    return;\n  }\n\n  const t = document.createElement(\"a\");\n  t.href = e, t.pathname !== window.location.pathname && window.location.assign(`${t.pathname}${t.hash}${t.search}`);\n}\n\nfunction b(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n\n  return r && r.then ? r.then(void 0, t) : r;\n}\n\nconst I = function (_ref4) {\n  let {\n    password: e,\n    existingPassword: t\n  } = _ref4;\n\n  try {\n    return Promise.resolve(b(function () {\n      if (!r.tokens.accessToken) throw new Error('updatePassword({ method: \"jwt\" }) was called without a JWT access token.');\n      return Promise.resolve(a(\"/auth/basic\", {\n        tenantId: r.tenantId,\n        password: e,\n        existingPassword: t\n      }, {\n        headers: {\n          Authorization: \"Bearer \" + r.tokens.accessToken\n        }\n      })).then(function (_ref5) {\n        let {\n          data: e\n        } = _ref5;\n        return e;\n      });\n    }, function (e) {\n      o(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n},\n      T = function (_ref6) {\n  let {\n    uuid: e,\n    token: t,\n    password: n,\n    redirect: i\n  } = _ref6;\n\n  try {\n    return Promise.resolve(b(function () {\n      if (t = t || P(\"token\"), e = e || P(\"uuid\"), !t || !e) throw new Error(\"Missing token or uuid\");\n      return Promise.resolve(a(\"/auth/reset\", {\n        tenantId: r.tenantId,\n        uuid: e,\n        token: t,\n        password: n\n      })).then(function (_ref7) {\n        let {\n          data: e\n        } = _ref7;\n        if (e.tokens) return m(e.tokens), y({\n          redirect: i,\n          data: e\n        }), e;\n        throw new Error(\"There was a problem resetting your password. Please try again.\");\n      });\n    }, function (e) {\n      o(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n},\n      E = function (_ref8) {\n  let {\n    method: e,\n    password: t,\n    existingPassword: n,\n    uuid: o,\n    token: i,\n    redirect: s\n  } = _ref8;\n\n  try {\n    switch (e) {\n      case \"link\":\n        return T({\n          uuid: o,\n          token: i,\n          password: t,\n          redirect: s\n        });\n\n      case \"jwt\":\n        return I({\n          password: t,\n          existingPassword: n\n        });\n\n      default:\n        if (i = i || P(\"token\"), (o = o || P(\"uuid\")) && i) return T({\n          uuid: o,\n          token: i,\n          password: t,\n          redirect: s\n        });\n        if (r.tokens.accessToken) return I({\n          password: t,\n          existingPassword: n\n        });\n        throw new Error(\"updatePassword() was called without link credentials (token & uuid) or a JWT access token.\");\n    }\n  } catch (e) {\n    return Promise.reject(e);\n  }\n},\n      j = E;\n\nfunction U(_ref9) {\n  let {\n    provider: e,\n    redirect: t\n  } = _ref9;\n  if (!e) throw new Error(\"Missing provider\");\n\n  const n = function (_ref10) {\n    let {\n      provider: e,\n      redirect: t\n    } = _ref10;\n    if (!e) throw new Error(\"Missing provider\");\n    if (!r.tenantId) throw new Error(\"Missing tenantId\");\n    let n = `${r.baseUrl}auth/${e}/login?tenant_id=${r.tenantId}&origin=${window.location.origin}`,\n        o = t || P(\"redirect\");\n    return !1 === t && (o = \"object\" == typeof document && document.location.pathname), o && (n += \"&redirect=\" + encodeURIComponent(o)), n;\n  }({\n    provider: e,\n    redirect: t\n  });\n\n  window.location.assign(n);\n}\n\nfunction C(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n\n  return r && r.then ? r.then(void 0, t) : r;\n}\n\nconst N = function (_ref11) {\n  let {\n    email: e,\n    name: t,\n    username: n,\n    userData: i,\n    options: s\n  } = _ref11;\n\n  try {\n    return Promise.resolve(C(function () {\n      return Promise.resolve(c(\"/auth/link\", {\n        email: e,\n        name: t,\n        username: n,\n        data: i,\n        options: s,\n        tenantId: r.tenantId\n      })).then(function (_ref12) {\n        let {\n          data: e\n        } = _ref12;\n        return e;\n      });\n    }, function (e) {\n      o(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nfunction $(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n\n  return r && r.then ? r.then(void 0, t) : r;\n}\n\nfunction O(_ref13) {\n  let {\n    channel: e,\n    phoneNumber: t,\n    email: r\n  } = _ref13;\n  if (\"sms\" !== e && \"email\" !== e) throw new Error(\"Invalid channel\");\n  if (\"sms\" === e && !t) throw new Error('SMS verification code requires \"phoneNumber\"');\n  if (\"email\" === e && !r) throw new Error('Email verification code requires \"email\"');\n}\n\nconst S = function (_ref14) {\n  let {\n    channel: e = \"sms\",\n    phoneNumber: t,\n    email: n,\n    name: i,\n    username: s,\n    data: a\n  } = _ref14;\n\n  try {\n    return Promise.resolve($(function () {\n      return O({\n        channel: e,\n        phoneNumber: t,\n        email: n\n      }), Promise.resolve(c(\"/auth/code\", {\n        channel: e,\n        email: n,\n        phoneNumber: t,\n        name: i,\n        username: s,\n        data: a,\n        tenantId: r.tenantId\n      })).then(function (_ref15) {\n        let {\n          data: e\n        } = _ref15;\n        return e;\n      });\n    }, function (e) {\n      o(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nfunction z(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n\n  return r && r.then ? r.then(void 0, t) : r;\n}\n\nfunction x(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n\n  return r && r.then ? r.then(void 0, t) : r;\n}\n\nconst M = /((^127\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.))\\d{1,3}\\.\\d{1,3}/g,\n      F = function () {\n  try {\n    const e = function (e, t) {\n      try {\n        var n = Promise.resolve(u(`/tenants/${r.tenantId}/mode`)).then(function (_ref16) {\n          let {\n            data: e\n          } = _ref16;\n          B.value = e.mode || \"test\", B.reason = R(B.value), r.mode = B.value;\n        });\n      } catch (e) {\n        return t();\n      }\n\n      return n && n.then ? n.then(void 0, t) : n;\n    }(0, function () {\n      B.value = \"test\", r.mode = B.value;\n    });\n\n    return Promise.resolve(e && e.then ? e.then(function () {}) : void 0);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n},\n      B = {\n  value: \"live\",\n  reason: void 0,\n  setMode: F\n};\n\nfunction L() {\n  const e = function (e) {\n    try {\n      const e = window.location.hostname;\n      return !(!e.match(/localhost/g) && !e.match(M));\n    } catch (e) {\n      return !0;\n    }\n  }() || !function () {\n    try {\n      return \"https:\" === window.location.protocol;\n    } catch (e) {\n      return !1;\n    }\n  }() ? \"test\" : \"live\";\n  B.value = e, B.reason = R(e), r.mode = e;\n}\n\nfunction R(e) {\n  try {\n    return \"live\" === e ? \"domain\" : \"http:\" === window.location.protocol ? \"http\" : \"https:\" !== window.location.protocol ? \"protocol\" : \"domain\";\n  } catch (e) {}\n}\n\nL(), r.user.update = function (e) {\n  try {\n    return !e || Object.keys(e).length < 1 ? Promise.resolve(console.warn(\"Missing user properties to update\")) : Promise.resolve(a(\"/self\", e, {\n      headers: {\n        authorization: \"Bearer \" + r.tokens.accessToken\n      }\n    })).then(function () {\n      return Promise.resolve(w()).then(function () {\n        return r.user;\n      });\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}, r.user.hasRole = function (e) {\n  let {\n    tenantId: t\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  try {\n    if (!r.tokens.accessToken || !r.tenantId) return !1;\n    const {\n      authorization: o\n    } = n(r.tokens.accessToken);\n    return !!o && !(!o[t = t || r.tenantId] || !o[t].roles) && o[t].roles.indexOf(e) > -1;\n  } catch (e) {\n    return !1;\n  }\n}, r.user.updatePassword = E, r.user.getTotp = function () {\n  try {\n    return Promise.resolve(z(function () {\n      if (!r.tokens.accessToken) throw new Error(\"getTotp() was called without a JWT access token.\");\n      return Promise.resolve(u(\"/auth/totp\", {\n        headers: {\n          Authorization: \"Bearer \" + r.tokens.accessToken\n        }\n      })).then(function (_ref17) {\n        let {\n          data: e\n        } = _ref17;\n        return e;\n      });\n    }, function (e) {\n      o(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nlet A = [],\n    q = !1;\nvar D = {\n  addInitCallback: function (e) {\n    e && \"function\" == typeof e && A.push(e);\n  },\n  init: function (t) {\n    let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!t) return console.warn(\"Userfront initialized without tenantId\");\n\n    if (r.tenantId = t, r.baseUrl = n.baseUrl || \"https://api.userfront.com/v0/\", r.baseUrl.endsWith(\"/\") || (r.baseUrl += \"/\"), n.domain) {\n      r.domain = n.domain;\n      const t = \"https://\" + r.domain;\n      e.defaults.headers.common[\"x-application-id\"] = t, e.defaults.headers.common[\"x-origin\"] = t;\n    }\n\n    r.tokens = r.tokens || {}, r.tokens.accessTokenName = \"access.\" + r.tenantId, r.tokens.idTokenName = \"id.\" + r.tenantId, r.tokens.refreshTokenName = \"refresh.\" + r.tenantId, v(), L();\n\n    try {\n      A.length > 0 && A.forEach(e => {\n        e && \"function\" == typeof e && e({\n          tenantId: t\n        });\n      }), A = [];\n    } catch (e) {}\n  },\n  registerUrlChangedEventListener: function () {\n    if (!q) {\n      q = !0;\n\n      try {\n        history.pushState = (e = history.pushState, function () {\n          var t = e.apply(this, arguments);\n          return window.dispatchEvent(new Event(\"pushstate\")), window.dispatchEvent(new Event(\"urlchanged\")), t;\n        }), history.replaceState = (e => function () {\n          var t = e.apply(this, arguments);\n          return window.dispatchEvent(new Event(\"replacestate\")), window.dispatchEvent(new Event(\"urlchanged\")), t;\n        })(history.replaceState), window.addEventListener(\"popstate\", () => {\n          window.dispatchEvent(new Event(\"urlchanged\"));\n        });\n      } catch (e) {}\n\n      var e;\n    }\n  },\n  logout: function () {\n    let {\n      method: e,\n      redirect: t\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      if (\"saml\" === e) return function () {\n        try {\n          if (!r.tokens.accessToken) throw new Error(\"Please log in to authorize your logout request.\");\n          const e = x(function () {\n            return Promise.resolve(u(\"/auth/saml/idp/token\", {\n              headers: {\n                authorization: \"Bearer \" + r.tokens.accessToken\n              }\n            })).then(function (_ref18) {\n              let {\n                data: e\n              } = _ref18;\n              window.location.assign(`${r.baseUrl}auth/saml/idp/logout?tenant_id=${r.tenantId}&token=${e.token}&uuid=${r.user.userUuid}`);\n            });\n          }, function (e) {\n            o(e);\n          });\n          return Promise.resolve(e && e.then ? e.then(function () {}) : void 0);\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }();\n      if (!r.tokens.accessToken) return Promise.resolve(l());\n      const n = x(function () {\n        return Promise.resolve(u(\"/auth/logout\", {\n          headers: {\n            authorization: \"Bearer \" + r.tokens.accessToken\n          }\n        })).then(function (_ref19) {\n          let {\n            data: e\n          } = _ref19;\n          l(), y({\n            redirect: t,\n            data: e\n          });\n        });\n      }, function () {\n        l();\n      });\n      return Promise.resolve(n && n.then ? n.then(function () {}) : void 0);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  mode: B,\n  setMode: F,\n  refresh: (e, t, r) => {\n    try {\n      console.warn(\"Userfront.refresh() is deprecated and will be removed. Please use Userfront.tokens.refresh() instead.\");\n    } catch (e) {}\n\n    return w();\n  },\n  login: function () {\n    let {\n      method: e,\n      userId: t,\n      userUuid: n,\n      email: i,\n      username: s,\n      emailOrUsername: d,\n      phoneNumber: h,\n      password: l,\n      token: f,\n      uuid: w,\n      totpCode: v,\n      backupCode: k,\n      channel: g,\n      verificationCode: I,\n      redirect: T\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      if (!e) throw new Error('Userfront.login called without \"method\" property.');\n\n      switch (e) {\n        case \"apple\":\n        case \"azure\":\n        case \"facebook\":\n        case \"github\":\n        case \"google\":\n        case \"linkedin\":\n          return Promise.resolve(U({\n            provider: e,\n            redirect: T\n          }));\n\n        case \"password\":\n          return Promise.resolve(function (_ref20) {\n            let {\n              email: e,\n              username: t,\n              emailOrUsername: n,\n              password: i,\n              redirect: s\n            } = _ref20;\n\n            try {\n              return Promise.resolve(b(function () {\n                return Promise.resolve(c(\"/auth/basic\", {\n                  tenantId: r.tenantId,\n                  emailOrUsername: e || t || n,\n                  password: i\n                })).then(function (_ref21) {\n                  let {\n                    data: e\n                  } = _ref21;\n                  let t;\n\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorCode\")) return e;\n                    throw new Error(\"Please try again.\");\n                  }\n\n                  const n = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return m(e.tokens), Promise.resolve(p(e)).then(function () {\n                      return y({\n                        redirect: s,\n                        data: e\n                      }), t = 1, e;\n                    });\n                  }();\n\n                  return n && n.then ? n.then(r) : r(n);\n                });\n              }, function (e) {\n                o(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            email: i,\n            username: s,\n            emailOrUsername: d,\n            password: l,\n            redirect: T\n          }));\n\n        case \"passwordless\":\n          return Promise.resolve(N({\n            email: i\n          }));\n\n        case \"link\":\n          return Promise.resolve(function () {\n            let {\n              token: e,\n              uuid: t,\n              redirect: n\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            try {\n              return Promise.resolve(C(function () {\n                if (e = e || P(\"token\"), t = t || P(\"uuid\"), e && t) return Promise.resolve(a(\"/auth/link\", {\n                  token: e,\n                  uuid: t,\n                  tenantId: r.tenantId\n                })).then(function (_ref22) {\n                  let {\n                    data: e\n                  } = _ref22;\n                  let t;\n\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorCode\")) return e;\n                    throw new Error(\"Problem logging in.\");\n                  }\n\n                  const o = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return m(e.tokens), Promise.resolve(p(e)).then(function () {\n                      return y({\n                        redirect: n,\n                        data: e\n                      }), t = 1, e;\n                    });\n                  }();\n\n                  return o && o.then ? o.then(r) : r(o);\n                });\n              }, function (e) {\n                o(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            token: f,\n            uuid: w,\n            redirect: T\n          }));\n\n        case \"totp\":\n          return Promise.resolve(function () {\n            let {\n              totpCode: e,\n              backupCode: t,\n              userId: n,\n              userUuid: i,\n              emailOrUsername: s,\n              email: a,\n              username: u,\n              phoneNumber: d,\n              redirect: h\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            try {\n              return Promise.resolve(z(function () {\n                if (e || t) return Promise.resolve(c(\"/auth/totp\", {\n                  totpCode: e,\n                  backupCode: t,\n                  userId: n,\n                  userUuid: i,\n                  emailOrUsername: s,\n                  email: a,\n                  username: u,\n                  phoneNumber: d,\n                  tenantId: r.tenantId\n                })).then(function (_ref23) {\n                  let {\n                    data: e\n                  } = _ref23;\n                  let t;\n\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorCode\")) return e;\n                    throw new Error(\"Problem logging in.\");\n                  }\n\n                  const n = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return m(e.tokens), Promise.resolve(p(e)).then(function () {\n                      return y({\n                        redirect: h,\n                        data: e\n                      }), t = 1, e;\n                    });\n                  }();\n\n                  return n && n.then ? n.then(r) : r(n);\n                });\n              }, function (e) {\n                o(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            totpCode: v,\n            backupCode: k,\n            userId: t,\n            userUuid: n,\n            emailOrUsername: d,\n            email: i,\n            username: s,\n            phoneNumber: h,\n            redirect: T\n          }));\n\n        case \"verificationCode\":\n          return Promise.resolve(function () {\n            let {\n              channel: e,\n              verificationCode: t,\n              email: n,\n              phoneNumber: i,\n              redirect: s\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            try {\n              return Promise.resolve($(function () {\n                return O({\n                  channel: e,\n                  phoneNumber: i,\n                  email: n\n                }), Promise.resolve(a(\"/auth/code\", {\n                  channel: e,\n                  verificationCode: t,\n                  email: n,\n                  phoneNumber: i,\n                  tenantId: r.tenantId\n                })).then(function (_ref24) {\n                  let {\n                    data: e\n                  } = _ref24;\n                  let t;\n\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorCode\")) return e;\n                    throw new Error(\"Problem logging in.\");\n                  }\n\n                  const n = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return m(e.tokens), Promise.resolve(p(e)).then(function () {\n                      return y({\n                        redirect: s,\n                        data: e\n                      }), t = 1, e;\n                    });\n                  }();\n\n                  return n && n.then ? n.then(r) : r(n);\n                });\n              }, function (e) {\n                o(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            channel: g,\n            email: i,\n            phoneNumber: h,\n            verificationCode: I,\n            redirect: T\n          }));\n\n        case \"saml\":\n          return Promise.resolve(function () {\n            try {\n              return Promise.resolve(function (e, t) {\n                try {\n                  var n = r.tokens.accessToken ? Promise.resolve(u(\"/auth/saml/idp/token\", {\n                    headers: {\n                      authorization: \"Bearer \" + r.tokens.accessToken\n                    }\n                  })).then(function (_ref25) {\n                    let {\n                      data: e\n                    } = _ref25;\n                    window.location.assign(`${r.baseUrl}auth/saml/idp/login?tenant_id=${r.tenantId}&token=${e.token}&uuid=${r.user.userUuid}`);\n                  }) : console.warn(\"Cannot complete SAML login without access token\");\n                } catch (e) {\n                  return t(e);\n                }\n\n                return n && n.then ? n.then(void 0, t) : n;\n              }(0, function (e) {\n                o(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }());\n\n        default:\n          throw new Error('Userfront.login called with invalid \"method\" property.');\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  resetPassword: j,\n  updatePassword: E,\n  sendLoginLink: function (e) {\n    try {\n      return Promise.resolve(C(function () {\n        return Promise.resolve(c(\"/auth/link\", {\n          email: e,\n          tenantId: r.tenantId\n        })).then(function (_ref26) {\n          let {\n            data: e\n          } = _ref26;\n          return e;\n        });\n      }, function (e) {\n        o(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  sendResetLink: function (e) {\n    try {\n      return Promise.resolve(b(function () {\n        return Promise.resolve(c(\"/auth/reset/link\", {\n          email: e,\n          tenantId: r.tenantId\n        })).then(function (_ref27) {\n          let {\n            data: e\n          } = _ref27;\n          return e;\n        });\n      }, function (e) {\n        o(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  sendVerificationCode: S,\n  signup: function () {\n    let {\n      method: e,\n      email: t,\n      username: n,\n      phoneNumber: i,\n      name: s,\n      data: a,\n      password: u,\n      channel: d,\n      redirect: h\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      if (!e) throw new Error('Userfront.signup called without \"method\" property.');\n\n      switch (e) {\n        case \"apple\":\n        case \"azure\":\n        case \"facebook\":\n        case \"github\":\n        case \"google\":\n        case \"linkedin\":\n          return Promise.resolve(U({\n            provider: e,\n            redirect: h\n          }));\n\n        case \"password\":\n          return Promise.resolve(function () {\n            let {\n              username: e,\n              name: t,\n              email: n,\n              password: i,\n              userData: s,\n              redirect: a\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            try {\n              return Promise.resolve(b(function () {\n                return Promise.resolve(c(\"/auth/create\", {\n                  tenantId: r.tenantId,\n                  username: e,\n                  name: t,\n                  email: n,\n                  password: i,\n                  data: s\n                })).then(function (_ref28) {\n                  let {\n                    data: e\n                  } = _ref28;\n                  if (e.tokens) return m(e.tokens), Promise.resolve(p(e)).then(function () {\n                    return y({\n                      redirect: a,\n                      data: e\n                    }), e;\n                  });\n                  throw new Error(\"Please try again.\");\n                });\n              }, function (e) {\n                o(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            username: n,\n            name: s,\n            email: t,\n            password: u,\n            userData: a,\n            redirect: h\n          }));\n\n        case \"passwordless\":\n          return Promise.resolve(N({\n            email: t,\n            name: s,\n            username: n,\n            userData: a\n          }));\n\n        case \"verificationCode\":\n          return Promise.resolve(S({\n            channel: d,\n            email: t,\n            phoneNumber: i,\n            name: s,\n            username: n,\n            data: a\n          }));\n\n        default:\n          throw new Error('Userfront.signup called with invalid \"method\" property.');\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  store: r,\n  tokens: k,\n  accessToken: function () {\n    return r.tokens.accessToken = t.get(r.tokens.accessTokenName), r.tokens.accessToken;\n  },\n  idToken: function () {\n    return r.tokens.idToken = t.get(r.tokens.idTokenName), r.tokens.idToken;\n  },\n  redirectIfLoggedIn: function () {\n    let {\n      redirect: e\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      if (!r.tokens.accessToken) return Promise.resolve(l());\n      if (e) return Promise.resolve(g(e));\n      if (P(\"redirect\")) return Promise.resolve(g(P(\"redirect\")));\n\n      const t = function (e, t) {\n        try {\n          var n = Promise.resolve(u(\"/self\", {\n            headers: {\n              authorization: \"Bearer \" + r.tokens.accessToken\n            }\n          })).then(function (_ref29) {\n            let {\n              data: e\n            } = _ref29;\n            e.tenant && e.tenant.loginRedirectPath && g(e.tenant.loginRedirectPath);\n          });\n        } catch (e) {\n          return t();\n        }\n\n        return n && n.then ? n.then(void 0, t) : n;\n      }(0, function () {\n        l();\n      });\n\n      return Promise.resolve(t && t.then ? t.then(function () {}) : void 0);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  user: i,\n  sendSms: function () {\n    let {\n      type: e,\n      phoneNumber: t,\n      firstFactorCode: n\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      if (!e) throw new Error('Userfront.sendSms called without \"type\" property.');\n\n      switch (e) {\n        case \"verificationCode\":\n          if (!t || !n) throw new Error('Userfront.sendSms type \"verificationCode\" requires \"phoneNumber\" and \"firstFactorCode\".');\n          return function () {\n            let {\n              firstFactorCode: e,\n              strategy: t,\n              channel: n,\n              phoneNumber: i\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            try {\n              if (!(e && t && n && i)) throw new Error(\"Userfront.sendMfaCode missing parameters.\");\n              return Promise.resolve(function (o, s) {\n                try {\n                  var a = Promise.resolve(c(\"/auth/mfa\", {\n                    tenantId: r.tenantId,\n                    firstFactorCode: e,\n                    strategy: t,\n                    channel: n,\n                    phoneNumber: i\n                  })).then(function (_ref30) {\n                    let {\n                      data: e\n                    } = _ref30;\n                    return e;\n                  });\n                } catch (e) {\n                  return s(e);\n                }\n\n                return a && a.then ? a.then(void 0, s) : a;\n              }(0, function (e) {\n                o(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            firstFactorCode: n,\n            phoneNumber: t,\n            strategy: \"verificationCode\",\n            channel: \"sms\"\n          });\n\n        default:\n          throw new Error('Userfront.sendSms called with invalid \"type\" property.');\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n};\nexport default D;","map":{"version":3,"mappings":"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","names":["store","user","tokens","mode","getJWTPayload","token","encodedPayload","split","replace","JSON","parse","atob","error","console","throwFormattedError","Error","response","_error$response","data","_error$response$data","message","reduceSlashes","str","put","path","payload","options","url","baseUrl","axios","post","get","setCookie","value","type","cookieName","tenantId","secure","sameSite","Cookies","set","removeCookie","name","paths","domains","window","location","pathname","hostname","primaryDomain","slice","join","undefined","err","map","domain","remove","removeAllCookies","accessTokenName","idTokenName","refreshTokenName","accessToken","idToken","refreshToken","attr","unsetUser","setCookiesAndTokens","access","cookieOptions","id","refresh","setTokensFromCookies","body","recover","result","e","then","exchange","headers","authorization","status","basicRefresh","warn","tokenName","idTokenPayload","propsToDefine","prop","setUser","getQueryAttr","attrName","href","indexOf","decodeURIComponent","handleRedirect","redirect","redirectToPath","redirectTo","pathOrUrl","document","el","createElement","assign","hash","search","updatePasswordWithJwt","existingPassword","password","Authorization","updatePasswordWithLink","uuid","updatePassword","method","resetPassword","signonWithSso","provider","origin","encodeURIComponent","getProviderLink","sendPasswordlessLink","email","username","userData","enforceChannel","channel","phoneNumber","sendVerificationCode","res","_catch","privateIPRegex","setMode","reason","getReason","setModeSync","modeValue","hn","match","isTestHostname","protocol","isHttps","update","Object","keys","length","Promise","hasRole","roleName","roles","getTotp","initCallbacks","isRegistered","addInitCallback","cb","push","init","opts","endsWith","defaults","common","forEach","registerUrlChangedEventListener","history","pushState","f","ret","apply","this","arguments","dispatchEvent","Event","replaceState","addEventListener","logout","userUuid","completeSamlLogout","a","b","c","login","userId","emailOrUsername","totpCode","backupCode","verificationCode","hasOwnProperty","_exit","loginWithPassword","loginWithLink","loginWithTotp","loginWithVerificationCode","completeSamlLogin","sendLoginLink","sendResetLink","signup","signupWithPassword","redirectIfLoggedIn","tenant","loginRedirectPath","sendSms","firstFactorCode","strategy","sendMfaCode"],"sources":["/home/theo/saas/frontend/node_modules/@userfront/core/src/store.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/utils.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/user.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/api.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/cookies.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/tokens.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/refresh.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/url.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/password.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/sso.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/link.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/verificationCode.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/totp.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/logout.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/constants.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/mode.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/user.methods.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/index.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/login.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/saml.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/signup.js","/home/theo/saas/frontend/node_modules/@userfront/core/src/mfa.js"],"sourcesContent":["export const store = {\n  user: {},\n  tokens: {},\n  mode: \"live\",\n};\n","/**\n * This file is for zero-dependency utilities that can\n * be imported by any other file. Don't add any imports\n * to this file other than constants\n */\n\n/**\n * Get the unverified base64 decoded payload of a JWT\n *\n * @param {String} token - JSON Web Token\n * @returns {Object}\n */\nexport function getJWTPayload(token) {\n  try {\n    const encodedPayload = token\n      .split(\".\")[1]\n      .replace(\"-\", \"+\")\n      .replace(\"_\", \"/\");\n    return JSON.parse(atob(encodedPayload));\n  } catch (error) {\n    console.error(\"Problem decoding JWT payload\", error);\n  }\n}\n\nexport function throwFormattedError(error) {\n  if (!error) return;\n  if (typeof error === \"string\") throw new Error(error);\n  if (error?.response?.data?.message) {\n    throw new Error(error.response.data.message);\n  }\n  throw error;\n}\n","import { store } from \"./store.js\";\nimport { getJWTPayload } from \"./utils.js\";\n\n/**\n * Define the store.user object based on the ID token\n */\nexport function setUser() {\n  if (!store.tokens.idToken) {\n    return console.warn(\"Cannot define user: missing ID token\");\n  }\n\n  store.user = store.user || {};\n  const idTokenPayload = getJWTPayload(store.tokens.idToken);\n\n  // Set basic user information properties from ID token\n  const propsToDefine = [\n    \"email\",\n    \"phoneNumber\",\n    \"username\",\n    \"name\",\n    \"image\",\n    \"data\",\n    \"confirmedAt\",\n    \"createdAt\",\n    \"updatedAt\",\n    \"mode\",\n    \"userId\",\n    \"userUuid\",\n    \"tenantId\",\n    \"isConfirmed\",\n  ];\n  for (const prop of propsToDefine) {\n    if (prop === \"update\") return;\n    store.user[prop] = idTokenPayload[prop];\n  }\n}\n\n/**\n * Remove all user information\n */\nexport function unsetUser() {\n  for (const attr in store.user) {\n    if (typeof store.user[attr] !== \"function\") {\n      delete store.user[attr];\n    }\n  }\n}\n\n/**\n * Export the store.user object with the update method added\n */\nexport const user = store.user;\n","import axios from \"axios\";\nimport { store } from \"./store.js\";\n\n// Replace multiple slashes // with single slash / (except in the protocol)\nfunction reduceSlashes(str) {\n  return str.replace(/([^:]\\/)\\/+/g, \"$1\");\n}\n\n/**\n * Perform a GET request\n * @param {String} path\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function get(path, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.get(url, options);\n}\n\n/**\n * Perform a POST request\n * @param {String} path\n * @param {Object} payload\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function post(path, payload, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.post(url, payload, options);\n}\n\n/**\n * Perform a PUT request\n * @param {String} path\n * @param {Object} payload\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function put(path, payload, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.put(url, payload, options);\n}\n\nexport default {\n  get,\n  post,\n  put,\n};\n","import Cookies from \"js-cookie\";\nimport { store } from \"./store.js\";\nimport { setTokensFromCookies, unsetTokens } from \"./tokens.js\";\n\n/**\n * Set a cookie value based on the given options.\n * @param {String} value\n * @param {Object} options\n * @param {String} type\n */\nexport function setCookie(value, options, type) {\n  const cookieName = `${type}.${store.tenantId}`;\n  options = options || {\n    secure: store.mode === \"live\",\n    sameSite: \"Lax\",\n  };\n  if (type === \"refresh\") {\n    options.sameSite = \"Strict\";\n  }\n  Cookies.set(cookieName, value, options);\n}\n\n/**\n * Remove a cookie by name, regardless of its cookie setting(s).\n * @param {String} name\n */\nfunction removeCookie(name) {\n  // Define all possible path and domain combinations\n  let paths, domains;\n  try {\n    const path = window.location.pathname;\n    const hostname = window.location.hostname;\n    const hostnameParts = hostname.split(\".\");\n    const primaryDomain = hostnameParts.slice(-2).join(\".\");\n    paths = [undefined, path, \"/\"];\n    domains = [\n      undefined,\n      hostname,\n      `.${hostname}`,\n      primaryDomain,\n      `.${primaryDomain}`,\n    ];\n  } catch (err) {\n    paths = [undefined, \"/\"];\n    domains = [undefined];\n  }\n\n  // Iterate over paths and domains, and remove cookies if present\n  paths.map((path) => {\n    domains.map((domain) => {\n      const options = {};\n      if (domain) options.domain = domain;\n      if (path) options.path = path;\n      Cookies.remove(name, options);\n    });\n  });\n}\n\n/**\n * Remove all auth cookies (access, id, refresh).\n */\nexport function removeAllCookies() {\n  removeCookie(store.tokens.accessTokenName);\n  removeCookie(store.tokens.idTokenName);\n  removeCookie(store.tokens.refreshTokenName);\n  unsetTokens();\n}\n\n/**\n * Set the cookies from a tokens object, and add to the local store.\n * @param {Object} tokens\n */\nexport function setCookiesAndTokens(tokens) {\n  setCookie(tokens.access.value, tokens.access.cookieOptions, \"access\");\n  setCookie(tokens.id.value, tokens.id.cookieOptions, \"id\");\n  if (tokens.refresh && tokens.refresh.value) {\n    setCookie(tokens.refresh.value, tokens.refresh.cookieOptions, \"refresh\");\n  }\n  setTokensFromCookies();\n}\n","import Cookies from \"js-cookie\";\nimport { store } from \"./store.js\";\nimport { setUser, unsetUser } from \"./user.js\";\nimport { refresh } from \"./refresh.js\";\n\nstore.tokens = store.tokens || {};\nstore.tokens.refresh = refresh;\n\nexport function setTokenNames() {\n  store.tokens = store.tokens || {};\n  store.tokens.accessTokenName = `access.${store.tenantId}`;\n  store.tokens.idTokenName = `id.${store.tenantId}`;\n  store.tokens.refreshTokenName = `refresh.${store.tenantId}`;\n}\n\n/**\n * Set and then return the access token\n */\nexport function accessToken() {\n  store.tokens.accessToken = Cookies.get(store.tokens.accessTokenName);\n  return store.tokens.accessToken;\n}\n\n/**\n * Set and then return the ID token\n */\nexport function idToken() {\n  store.tokens.idToken = Cookies.get(store.tokens.idTokenName);\n  return store.tokens.idToken;\n}\n\n/**\n * Define the store token values from the cookie values.\n */\nexport function setTokensFromCookies() {\n  const tokenNames = [\"access\", \"id\", \"refresh\"];\n  tokenNames.map((tokenName) => {\n    try {\n      const token = Cookies.get(store.tokens[`${tokenName}TokenName`]);\n      store.tokens[`${tokenName}Token`] = token;\n\n      // Set the user object whenever the ID token is set\n      if (tokenName === \"id\" && token) {\n        setUser();\n      }\n    } catch (error) {\n      console.warn(`Problem setting ${tokenName} token.`);\n    }\n  });\n}\n\n/**\n * Set the store token values to undefined\n */\nexport function unsetTokens() {\n  store.tokens.accessToken = undefined;\n  store.tokens.idToken = undefined;\n  store.tokens.refreshToken = undefined;\n  unsetUser();\n}\n\n/**\n * Export the store.tokens object\n */\nexport const tokens = store.tokens;\n\n// NOTE Commenting this out 6/11/21 because the packages it relies on (jsonwebtoken & jwks-rsa)\n// both cause a lot of bloat. If we want to verify tokens, this is a nice way to do it, but\n// we need to find libraries designed for the browser instead of node.\n/**\n * Verify the provided token\n * @param {String} token\n * @returns {Promise<void>} The provided token has been verified if `verifyToken` resolves without error\n */\n// export async function verifyToken(token) {\n//   if (!token) throw new Error(\"Missing token\");\n\n//   let publicKey;\n//   try {\n//     const decodedToken = jwt.decode(token, { complete: true });\n//     if (!decodedToken.header || !decodedToken.header.kid) {\n//       throw new Error(\"Token kid not defined\");\n//     }\n\n//     const client = new JwksClient({\n//       jwksUri: `${apiUrl}tenants/${store.tenantId}/jwks/${store.mode}`,\n//       requestHeaders: { origin: window.location.origin },\n//     });\n\n//     const key = await client.getSigningKey(decodedToken.header.kid);\n//     publicKey = key.getPublicKey();\n//   } catch (error) {\n//     throw error;\n//   }\n\n//   if (!publicKey) {\n//     throw new Error(\"Public key not found\");\n//   }\n\n//   try {\n//     jwt.verify(token, publicKey);\n//   } catch (error) {\n//     throw new Error(\"Token verification failed\");\n//   }\n\n//   return Promise.resolve();\n// }\n","import Cookies from \"js-cookie\";\nimport { get } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\n// import { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Refresh the access and ID tokens\n * - When in test mode, uses the basic refresh method\n * - For tenants without a custom SSL certificate, uses the basic refresh method\n * - For tenants with a custom SSL certificate and in live mode, uses the httpOnly refresh method\n * @returns {Promise}\n */\nexport async function refresh() {\n  try {\n    await basicRefresh();\n  } catch (error) {\n    console.warn(`Refresh failed: ${error.message}`);\n  }\n}\n\n/**\n * Use a regular (non-httpOnly) cookie to refresh the access and ID tokens.\n *\n * The basic refresh method is used automatically in test mode and in live\n * mode whenever an SSL certificate has not been set up.\n */\nasync function basicRefresh() {\n  const refreshToken = Cookies.get(store.tokens.refreshTokenName);\n  try {\n    const { data, status } = await get(`/auth/refresh`, {\n      headers: {\n        authorization: `Bearer ${refreshToken}`,\n      },\n    });\n    if (status !== 200) {\n      throw new Error(data.message || \"Problem with request\");\n    }\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      return data;\n    } else {\n      throw new Error(\"Problem setting cookies\");\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n// TODO re-enable httpOnly refresh method once new endpoints are stable [06/15/21]\n/**\n *\n * The httpOnly refresh method is only available for tenants with configured\n * SSL certificates while in live mode.\n */\n// async function httpOnlyRefresh() {\n//   const iframe = getIframe();\n//   if (!iframe) return;\n//   return postMessageAsPromise({\n//     type: \"refresh\",\n//     tenantId: store.tenantId,\n//   });\n// }\n\n/**\n * Use a sessionId and nonce to set the iframe refresh token\n * @param {String} sessionId\n * @param {String} nonce\n * @returns {Promise}\n */\nexport async function exchange({ sessionId, nonce }) {\n  return;\n\n  // TODO re-enable httpOnly exchange method once new endpoints are stable [06/15/21]\n  // --------------------------\n  // const iframe = getIframe();\n  // if (!iframe) return;\n  // return postMessageAsPromise({\n  //   type: \"exchange\",\n  //   tenantId: store.tenantId,\n  //   payload: {\n  //     sessionId,\n  //     nonce,\n  //   },\n  // });\n}\n","import { get } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\n\n/**\n * Get the value of a query attribute, e.g. ?attr=value\n * @param {String} attrName\n */\nexport function getQueryAttr(attrName) {\n  if (\n    typeof window !== \"object\" ||\n    typeof window.location !== \"object\" ||\n    !window.location.href ||\n    window.location.href.indexOf(`${attrName}=`) < 0\n  ) {\n    return;\n  }\n  return decodeURIComponent(\n    window.location.href.split(`${attrName}=`)[1].split(\"&\")[0]\n  );\n}\n\n/**\n * Redirect the browser based on explicit redirect input path, or the API response\n * @property {String|Boolean} redirect A path to redirect to, or false to not redirect\n * @property {Object} data The response object from the API\n * @returns\n */\nexport const handleRedirect = ({ redirect, data }) => {\n  if (redirect === false) return;\n  const path = redirect || getQueryAttr(\"redirect\") || data.redirectTo || \"/\";\n  redirectToPath(path);\n};\n\n// TODO replace with direct check of the access token.\n/**\n * If the access token is valid, redirect the browser to the\n * tenant's login redirection path (path after login).\n */\nexport async function redirectIfLoggedIn({ redirect } = {}) {\n  if (!store.tokens.accessToken) {\n    return removeAllCookies();\n  }\n\n  // Redirect to a provided path (check options first, then url querystring)\n  if (redirect) {\n    return redirectToPath(redirect);\n  } else if (getQueryAttr(\"redirect\")) {\n    return redirectToPath(getQueryAttr(\"redirect\"));\n  }\n\n  // If no path was provided, look up the path and then redirect there\n  try {\n    const { data } = await get(`/self`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    if (data.tenant && data.tenant.loginRedirectPath) {\n      redirectToPath(data.tenant.loginRedirectPath);\n    }\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\n/**\n * Redirect to path portion of a URL.\n */\nexport function redirectToPath(pathOrUrl) {\n  // Return if no pathOrUrl, or if SSR or mobile\n  if (\n    !pathOrUrl ||\n    typeof document !== \"object\" ||\n    typeof window !== \"object\"\n  ) {\n    return;\n  }\n  try {\n    document && window;\n  } catch (error) {\n    return;\n  }\n\n  // Perform hard redirect\n  const el = document.createElement(\"a\");\n  el.href = pathOrUrl;\n  let path = `${el.pathname}${el.hash}${el.search}`;\n  if (el.pathname !== window.location.pathname) {\n    window.location.assign(path);\n  }\n}\n","import { post, put } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { getQueryAttr, handleRedirect } from \"./url.js\";\nimport { throwFormattedError } from \"./utils.js\";\nimport { exchange } from \"./refresh.js\";\n\n/**\n * Register a new user with username, name, email, and password.\n * Redirect the browser after successful signup based on the redirectTo value returned.\n * @param {String} username\n * @param {String} name\n * @param {String} email\n * @param {String} password\n * @param {Object} userData - alias for the user.data object, since \"data\" is used in the response\n * @param {String} redirect - do not redirect if false, or redirect to a specific path\n */\nexport async function signupWithPassword({\n  username,\n  name,\n  email,\n  password,\n  userData,\n  redirect,\n} = {}) {\n  try {\n    const { data } = await post(`/auth/create`, {\n      tenantId: store.tenantId,\n      username,\n      name,\n      email,\n      password,\n      data: userData,\n    });\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    } else {\n      throw new Error(\"Please try again.\");\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log a user in with email/username and password.\n * Redirect the browser after successful login based on the redirectTo value returned.\n * @param {Object} options\n */\nexport async function loginWithPassword({\n  email,\n  username,\n  emailOrUsername,\n  password,\n  redirect,\n}) {\n  try {\n    const { data } = await post(`/auth/basic`, {\n      tenantId: store.tenantId,\n      emailOrUsername: email || username || emailOrUsername,\n      password,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Please try again.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Send a password reset link to the provided email.\n * @param {String} email\n */\nexport async function sendResetLink(email) {\n  try {\n    const { data } = await post(`/auth/reset/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Set a user's password with their link credentials or JWT access token.\n *\n * If no method is provided, the order is:\n * - Check for link credentials; then\n * - Check for a JWT access token first\n *\n * @property {String} method (optional) \"link\" or \"jwt\"\n * @property {String} password\n * @property {String} existingPassword\n * @property {String} uuid\n * @property {String} token\n * @property {String} redirect\n * @returns\n */\nexport async function updatePassword({\n  method,\n  password,\n  existingPassword,\n  uuid,\n  token,\n  redirect,\n}) {\n  switch (method) {\n    // Allow for explicit setting of method\n    case \"link\":\n      return updatePasswordWithLink({ uuid, token, password, redirect });\n    case \"jwt\":\n      return updatePasswordWithJwt({ password, existingPassword });\n    default:\n      // Default (no method provided) is to look for link credentials first, then JWT access token\n      token = token || getQueryAttr(\"token\");\n      uuid = uuid || getQueryAttr(\"uuid\");\n      if (uuid && token) {\n        return updatePasswordWithLink({ uuid, token, password, redirect });\n      } else if (store.tokens.accessToken) {\n        return updatePasswordWithJwt({ password, existingPassword });\n      } else {\n        throw new Error(\n          \"updatePassword() was called without link credentials (token & uuid) or a JWT access token.\"\n        );\n      }\n  }\n}\n\nexport const resetPassword = updatePassword;\n\nexport async function updatePasswordWithLink({\n  uuid,\n  token,\n  password,\n  redirect,\n}) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) throw new Error(\"Missing token or uuid\");\n    const { data } = await put(`/auth/reset`, {\n      tenantId: store.tenantId,\n      uuid,\n      token,\n      password,\n    });\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      handleRedirect({ redirect, data });\n      return data;\n    } else {\n      throw new Error(\n        \"There was a problem resetting your password. Please try again.\"\n      );\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\nexport async function updatePasswordWithJwt({ password, existingPassword }) {\n  try {\n    if (!store.tokens.accessToken) {\n      throw new Error(\n        `updatePassword({ method: \"jwt\" }) was called without a JWT access token.`\n      );\n    }\n\n    const { data } = await put(\n      `/auth/basic`,\n      {\n        tenantId: store.tenantId,\n        password,\n        existingPassword,\n      },\n      {\n        headers: {\n          Authorization: `Bearer ${store.tokens.accessToken}`,\n        },\n      }\n    );\n\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { store } from \"./store.js\";\nimport { getQueryAttr } from \"./url.js\";\n\nexport function getProviderLink({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  if (!store.tenantId) throw new Error(\"Missing tenantId\");\n\n  let url = `${store.baseUrl}auth/${provider}/login?tenant_id=${store.tenantId}&origin=${window.location.origin}`;\n\n  let redirectTo = redirect || getQueryAttr(\"redirect\");\n  if (redirect === false) {\n    redirectTo = typeof document === \"object\" && document.location.pathname;\n  }\n  if (redirectTo) {\n    url += `&redirect=${encodeURIComponent(redirectTo)}`;\n  }\n\n  return url;\n}\n\n/**\n * Log in or register a user via SSO provider.\n * Redirect the browser after successful authentication and 302 redirect from server.\n * @param {String} provider Name of SSO provider\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport function signonWithSso({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  const url = getProviderLink({ provider, redirect });\n  window.location.assign(url);\n}\n","import { post, put } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { getQueryAttr, handleRedirect } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Log a user in with a token/uuid combo passed into the function or\n * in the URL querystring. ?token=...&uuid=...\n * @param {String} token\n * @param {UUID} uuid\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithLink({ token, uuid, redirect } = {}) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) return;\n\n    const { data } = await put(\"/auth/link\", {\n      token,\n      uuid,\n      tenantId: store.tenantId,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Problem logging in.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Send a login link to the provided email.\n * @param {String} email\n */\nexport async function sendLoginLink(email) {\n  try {\n    const { data } = await post(`/auth/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Create or update a user and send them a link to log in.\n * @param {Object} inputs\n */\nexport async function sendPasswordlessLink({\n  email,\n  name,\n  username,\n  userData,\n  options,\n}) {\n  try {\n    const { data } = await post(`/auth/link`, {\n      email,\n      name,\n      username,\n      data: userData,\n      options,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { post, put } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { handleRedirect } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Verify that proper identifier is available for the channel\n * @property {String} channel \"sms\" or \"email\"\n * @property {String} phoneNumber\n * @property {String} email\n */\nfunction enforceChannel({ channel, phoneNumber, email }) {\n  if (channel !== \"sms\" && channel !== \"email\") {\n    throw new Error(\"Invalid channel\");\n  }\n  if (channel === \"sms\" && !phoneNumber) {\n    throw new Error(`SMS verification code requires \"phoneNumber\"`);\n  } else if (channel === \"email\" && !email) {\n    throw new Error(`Email verification code requires \"email\"`);\n  }\n}\n\n/**\n * Send a verification code to the provided email address or phone number.\n * @property {String} channel \"sms\" (default) or \"email\"\n * @property {String} phoneNumber\n * @property {String} email\n * @property {String} name\n * @property {String} username\n * @property {Object} data\n */\nexport async function sendVerificationCode({\n  channel = \"sms\",\n  phoneNumber,\n  email,\n  name,\n  username,\n  data,\n}) {\n  try {\n    enforceChannel({\n      channel,\n      phoneNumber,\n      email,\n    });\n\n    const { data: res } = await post(`/auth/code`, {\n      channel,\n      email,\n      phoneNumber,\n      name,\n      username,\n      data,\n      tenantId: store.tenantId,\n    });\n    return res;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log a user in with a token/uuid combo passed into the function or\n * in the URL querystring. ?token=...&uuid=...\n * @param {String} token\n * @param {UUID} uuid\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithVerificationCode({\n  channel,\n  verificationCode,\n  email,\n  phoneNumber,\n  redirect,\n} = {}) {\n  try {\n    enforceChannel({\n      channel,\n      phoneNumber,\n      email,\n    });\n\n    const { data } = await put(`/auth/code`, {\n      channel,\n      verificationCode,\n      email,\n      phoneNumber,\n      tenantId: store.tenantId,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Problem logging in.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { get, post } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { handleRedirect } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Log a user in with a TOTP authenticator code or a TOTP backup code,\n * plus an identifier for the user (e.g. userId, userUuid, or email)\n *\n * @property {String} totpCode \"123456\"\n * @property {String} backupCode \"aaaaa-bbbbb\"\n * @property {Integer} userId\n * @property {String} userUuid\n * @property {String} emailOrUsername\n * @property {String} email\n * @property {String} username\n * @property {String} phoneNumber\n * @property {String|Boolean} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithTotp({\n  totpCode,\n  backupCode,\n  userId,\n  userUuid,\n  emailOrUsername,\n  email,\n  username,\n  phoneNumber,\n  redirect,\n} = {}) {\n  try {\n    if (!totpCode && !backupCode) return;\n\n    const { data } = await post(`/auth/totp`, {\n      totpCode,\n      backupCode,\n      userId,\n      userUuid,\n      emailOrUsername,\n      email,\n      username,\n      phoneNumber,\n      tenantId: store.tenantId,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Problem logging in.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\nexport async function getTotp() {\n  try {\n    if (!store.tokens.accessToken) {\n      throw new Error(`getTotp() was called without a JWT access token.`);\n    }\n\n    const { data } = await get(`/auth/totp`, {\n      headers: {\n        Authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { get } from \"./api.js\";\nimport { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\nimport { setTokensFromCookies } from \"./tokens.js\";\nimport { handleRedirect } from \"./url\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Log a user out and redirect to the logout path.\n */\nexport async function logout({ method, redirect } = {}) {\n  if (method === \"saml\") {\n    return completeSamlLogout();\n  }\n  if (!store.tokens.accessToken) {\n    return removeAllCookies();\n  }\n\n  try {\n    const { data } = await get(`/auth/logout`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    removeAllCookies();\n    handleRedirect({ redirect, data });\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\nasync function completeSamlLogout() {\n  if (!store.tokens.accessToken) {\n    throw new Error(\"Please log in to authorize your logout request.\");\n  }\n\n  try {\n    const { data } = await get(`/auth/saml/idp/token`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    window.location.assign(\n      `${store.baseUrl}auth/saml/idp/logout?tenant_id=${store.tenantId}&token=${data.token}&uuid=${store.user.userUuid}`\n    );\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n// TODO re-enable exchange method once new endpoints are stable [06/15/21]\n// --------------------------\n// const iframe = getIframe();\n// if (!iframe) return;\n// try {\n//   const { data } = await postMessageAsPromise({\n//     type: \"logout\",\n//     tenantId: store.tenantId,\n//   });\n//   removeAllCookies();\n//   setTokensFromCookies();\n//   handleRedirect({ redirect, data });\n// } catch (error) {\n//   removeAllCookies();\n//   redirectToPath(\"/\");\n// }\n","export const apiUrl = `https://api.userfront.com/v0/`;\n\nexport const privateIPRegex =\n  /((^127\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.))\\d{1,3}\\.\\d{1,3}/g;\n","import { get } from \"./api.js\";\nimport { privateIPRegex } from \"./constants.js\";\nimport { store } from \"./store.js\";\n\n/**\n * Global mode object\n */\nexport const mode = {\n  value: \"live\",\n  reason: undefined,\n  setMode,\n};\n\nsetModeSync();\n\n/**\n * Determine whether a hostname is in test mode.\n * @param {String} hn\n */\nexport function isTestHostname(hn) {\n  try {\n    const hostname = hn || window.location.hostname;\n    return !!(hostname.match(/localhost/g) || hostname.match(privateIPRegex));\n  } catch (err) {\n    return true;\n  }\n}\n\nexport function isHttps() {\n  try {\n    return window.location.protocol === \"https:\";\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Define the mode of operation (live or test)\n */\nexport async function setMode() {\n  try {\n    const { data } = await get(`/tenants/${store.tenantId}/mode`);\n    mode.value = data.mode || \"test\";\n    mode.reason = getReason(mode.value);\n    store.mode = mode.value;\n  } catch (err) {\n    mode.value = \"test\";\n    store.mode = mode.value;\n  }\n}\n\n/**\n * Estimate the mode without making an API call\n */\nexport function setModeSync() {\n  const modeValue = isTestHostname() || !isHttps() ? \"test\" : \"live\";\n  mode.value = modeValue;\n  mode.reason = getReason(modeValue);\n  store.mode = modeValue;\n}\n\n/**\n * Set the reason for the mode\n * - http\n * - domain\n */\nfunction getReason(mode) {\n  try {\n    if (mode === \"live\") {\n      return \"domain\";\n    }\n    if (window.location.protocol === \"http:\") {\n      return \"http\";\n    } else if (window.location.protocol !== \"https:\") {\n      return \"protocol\";\n    } else {\n      return \"domain\";\n    }\n  } catch (error) {}\n}\n","/**\n * user methods are refactored into a separate file to avoid a circular dependency\n * between Userfront.refresh() [which requires setUser()]\n * and Userfront.user.update() [which requires refresh()].\n */\nimport { put } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { refresh } from \"./refresh.js\";\nimport { getTotp } from \"./totp.js\";\nimport { getJWTPayload } from \"./utils.js\";\nimport { updatePassword } from \"./password.js\";\n\n/**\n * Update the user record on Userfront\n * @param {Object} payload User properties to update e.g. { name: 'John Doe' }\n */\nexport async function update(payload) {\n  if (!payload || Object.keys(payload).length < 1) {\n    return console.warn(\"Missing user properties to update\");\n  }\n\n  // Make request to update the user\n  await put(`/self`, payload, {\n    headers: {\n      authorization: `Bearer ${store.tokens.accessToken}`,\n    },\n  });\n\n  // Refresh the access and ID tokens, and set the store.user object from the ID token\n  await refresh();\n\n  return store.user;\n}\n\n/**\n * Determine whether the access token has a given role\n * @param {String} roleName\n * @param {Object} options\n * @returns {Boolean}\n */\nexport function hasRole(roleName, { tenantId } = {}) {\n  try {\n    if (!store.tokens.accessToken || !store.tenantId) {\n      return false;\n    }\n    const { authorization } = getJWTPayload(store.tokens.accessToken);\n    if (!authorization) {\n      return false;\n    }\n    tenantId = tenantId || store.tenantId;\n    if (!authorization[tenantId] || !authorization[tenantId].roles) {\n      return false;\n    }\n    return authorization[tenantId].roles.indexOf(roleName) > -1;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Add the methods to the store.user object\n */\nstore.user.update = update;\nstore.user.hasRole = hasRole;\nstore.user.updatePassword = updatePassword;\nstore.user.getTotp = getTotp;\n","import axios from \"axios\";\nimport { store } from \"./store.js\";\nimport {\n  tokens,\n  accessToken,\n  idToken,\n  setTokensFromCookies,\n  setTokenNames,\n} from \"./tokens\";\nimport { redirectIfLoggedIn } from \"./url.js\";\nimport { sendSms } from \"./mfa.js\";\nimport { signup } from \"./signup.js\";\nimport { login } from \"./login.js\";\nimport { updatePassword, resetPassword, sendResetLink } from \"./password.js\";\nimport { sendLoginLink } from \"./link.js\";\nimport { sendVerificationCode } from \"./verificationCode\";\nimport { logout } from \"./logout.js\";\nimport { mode, setMode, setModeSync } from \"./mode.js\";\n// import { setIframe } from \"./iframe.js\";\nimport { user } from \"./user.js\";\nimport \"./user.methods.js\";\nimport { refresh } from \"./refresh.js\";\nimport { apiUrl } from \"./constants.js\";\n\nlet initCallbacks = [];\n\n/**\n * Initialize the Userfront library.\n * @param {String} tenantId\n */\nfunction init(tenantId, opts = {}) {\n  if (!tenantId) return console.warn(\"Userfront initialized without tenantId\");\n\n  store.tenantId = tenantId;\n\n  store.baseUrl = opts.baseUrl || apiUrl;\n  if (!store.baseUrl.endsWith(\"/\")) {\n    store.baseUrl += \"/\";\n  }\n\n  if (opts.domain) {\n    store.domain = opts.domain;\n    const url = `https://${store.domain}`;\n    axios.defaults.headers.common[\"x-application-id\"] = url;\n    axios.defaults.headers.common[\"x-origin\"] = url;\n  }\n\n  setTokenNames();\n  // setIframe(); // TODO re-enable when iframe is needed\n  setTokensFromCookies();\n  setModeSync();\n\n  try {\n    if (initCallbacks.length > 0) {\n      initCallbacks.forEach((cb) => {\n        if (!cb || typeof cb !== \"function\") return;\n        cb({ tenantId });\n      });\n    }\n    initCallbacks = [];\n  } catch (error) {}\n}\n\n/**\n * Add a callback function to be called upon Userfront.init()\n * @param {Function} cb\n */\nfunction addInitCallback(cb) {\n  if (!cb || typeof cb !== \"function\") return;\n  initCallbacks.push(cb);\n}\n\n/**\n\n * Register a window-level event called \"urlchanged\" that will fire\n * whenever the browser URL changes.\n */\nlet isRegistered = false;\nfunction registerUrlChangedEventListener() {\n  if (isRegistered) return;\n  isRegistered = true;\n  try {\n    history.pushState = ((f) =>\n      function pushState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"pushstate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.pushState);\n\n    history.replaceState = ((f) =>\n      function replaceState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"replacestate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.replaceState);\n\n    window.addEventListener(\"popstate\", () => {\n      window.dispatchEvent(new Event(\"urlchanged\"));\n    });\n  } catch (error) {}\n}\n\n/**\n * EXPORTS\n */\n\nexport default {\n  // index\n  addInitCallback,\n  init,\n  registerUrlChangedEventListener,\n\n  //logout\n  logout,\n\n  // mode\n  mode,\n  setMode,\n\n  // refresh\n  refresh: (a, b, c) => {\n    try {\n      console.warn(\n        \"Userfront.refresh() is deprecated and will be removed. Please use Userfront.tokens.refresh() instead.\"\n      );\n    } catch (error) {}\n    return refresh(a, b, c);\n  },\n\n  // signon\n  login,\n  resetPassword,\n  updatePassword,\n  sendLoginLink,\n  sendResetLink,\n  sendVerificationCode,\n  signup,\n\n  // store\n  store,\n\n  // tokens\n  tokens,\n  accessToken,\n  idToken,\n\n  // url\n  redirectIfLoggedIn,\n\n  // user\n  user,\n\n  // mfa\n  sendSms,\n\n  // utils\n};\n","import { loginWithPassword } from \"./password.js\";\nimport { loginWithLink, sendPasswordlessLink } from \"./link.js\";\nimport { signonWithSso } from \"./sso.js\";\nimport { loginWithTotp } from \"./totp.js\";\nimport { loginWithVerificationCode } from \"./verificationCode.js\";\nimport { completeSamlLogin } from \"./saml.js\";\n\n/**\n * Log a user in via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {String} method\n * @param {Number} userId\n * @param {String} userUuid\n * @param {String} email\n * @param {String} username\n * @param {String} emailOrUsername\n * @param {String} phoneNumber\n * @param {String} password\n * @param {String} token\n * @param {String} uuid\n * @param {String} totpCode\n * @param {String} backupCode\n * @param {String} channel \"sms\" or \"email\"\n * @param {String} verificationCode\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function login({\n  method,\n  // User identifiers\n  userId,\n  userUuid,\n  email,\n  username,\n  emailOrUsername,\n  phoneNumber,\n  // Password\n  password,\n  // Link\n  token,\n  uuid,\n  // Totp\n  totpCode,\n  backupCode,\n  // Verification code\n  channel,\n  verificationCode,\n  // Other\n  redirect,\n} = {}) {\n  if (!method) {\n    throw new Error('Userfront.login called without \"method\" property.');\n  }\n  switch (method) {\n    case \"apple\":\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return signonWithSso({ provider: method, redirect });\n    case \"password\":\n      return loginWithPassword({\n        email,\n        username,\n        emailOrUsername,\n        password,\n        redirect,\n      });\n    case \"passwordless\":\n      return sendPasswordlessLink({ email });\n    case \"link\":\n      return loginWithLink({ token, uuid, redirect });\n    case \"totp\":\n      return loginWithTotp({\n        totpCode,\n        backupCode,\n        userId,\n        userUuid,\n        emailOrUsername,\n        email,\n        username,\n        phoneNumber,\n        redirect,\n      });\n    case \"verificationCode\":\n      return loginWithVerificationCode({\n        channel,\n        email,\n        phoneNumber,\n        verificationCode,\n        redirect,\n      });\n    case \"saml\":\n      return completeSamlLogin();\n    default:\n      throw new Error('Userfront.login called with invalid \"method\" property.');\n  }\n}\n","import { get } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\nexport async function completeSamlLogin() {\n  try {\n    if (!store.tokens.accessToken) {\n      return console.warn(\"Cannot complete SAML login without access token\");\n    }\n\n    const { data } = await get(`/auth/saml/idp/token`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    window.location.assign(\n      `${store.baseUrl}auth/saml/idp/login?tenant_id=${store.tenantId}&token=${data.token}&uuid=${store.user.userUuid}`\n    );\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { signupWithPassword } from \"./password.js\";\nimport { signonWithSso } from \"./sso.js\";\nimport { sendPasswordlessLink } from \"./link.js\";\nimport { sendVerificationCode } from \"./verificationCode.js\";\n\n/**\n * Register a user via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {String} method\n * @param {String} email\n * @param {String} username\n * @param {String} phoneNumber\n * @param {String} name\n * @param {Object} data - Object for custom user fields\n * @param {String} password\n * @param {String} channel \"sms\" or \"email\"\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function signup({\n  method,\n  email,\n  username,\n  phoneNumber,\n  name,\n  data,\n  password,\n  channel,\n  redirect,\n} = {}) {\n  if (!method) {\n    throw new Error('Userfront.signup called without \"method\" property.');\n  }\n  switch (method) {\n    case \"apple\":\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return signonWithSso({ provider: method, redirect });\n    case \"password\":\n      return signupWithPassword({\n        username,\n        name,\n        email,\n        password,\n        userData: data,\n        redirect,\n      });\n    case \"passwordless\":\n      return sendPasswordlessLink({ email, name, username, userData: data });\n    case \"verificationCode\":\n      return sendVerificationCode({\n        channel,\n        email,\n        phoneNumber,\n        name,\n        username,\n        data,\n      });\n    default:\n      throw new Error(\n        'Userfront.signup called with invalid \"method\" property.'\n      );\n  }\n}\n","import { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { handleRedirect } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\nimport { post, put } from \"./api.js\";\n\n/**\n * Send an SMS to a phone number\n * @param {String} type Type of SMS to send\n * @param {String} phoneNumber Phone number in E.164 format\n * @param {String} firstFactorCode Identifier obtained from login() response\n * @returns {Object}\n */\nexport async function sendSms({ type, phoneNumber, firstFactorCode } = {}) {\n  if (!type) {\n    throw new Error('Userfront.sendSms called without \"type\" property.');\n  }\n\n  switch (type) {\n    case \"verificationCode\":\n      if (!phoneNumber || !firstFactorCode) {\n        throw new Error(\n          'Userfront.sendSms type \"verificationCode\" requires \"phoneNumber\" and \"firstFactorCode\".'\n        );\n      }\n\n      return sendMfaCode({\n        firstFactorCode,\n        phoneNumber,\n        strategy: \"verificationCode\",\n        channel: \"sms\",\n      });\n    default:\n      throw new Error('Userfront.sendSms called with invalid \"type\" property.');\n  }\n}\n\n/**\n * Send an MFA verification code\n * @param {String} firstFactorCode Identifier obtained from login() response\n * @param {String} strategy Type of MFA strategy\n * @param {String} channel Method of sending the verification code\n * @param {String} phoneNumber Phone number in E.164 format\n * @returns {Object}\n */\nexport async function sendMfaCode({\n  firstFactorCode,\n  strategy,\n  channel,\n  phoneNumber,\n} = {}) {\n  if (!firstFactorCode || !strategy || !channel || !phoneNumber) {\n    throw new Error(\"Userfront.sendMfaCode missing parameters.\");\n  }\n\n  try {\n    const { data } = await post(`/auth/mfa`, {\n      tenantId: store.tenantId,\n      firstFactorCode,\n      strategy,\n      channel,\n      phoneNumber,\n    });\n\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log in using firstFactorCode and MFA verification code\n * @param {String} firstFactorCode Identifier obtained from login() response\n * @param {String} verificationCode Code provided by the user\n * @param {String|Boolean} redirect Redirect to given path unless specified as `false`\n * @returns {Object}\n */\nexport async function loginWithMfa({\n  firstFactorCode,\n  verificationCode,\n  redirect,\n} = {}) {\n  if (!firstFactorCode || !verificationCode) {\n    throw new Error(\"Userfront.loginWithMfa missing parameters.\");\n  }\n\n  try {\n    const { data } = await put(`/auth/mfa`, {\n      tenantId: store.tenantId,\n      firstFactorCode,\n      verificationCode,\n    });\n\n    setCookiesAndTokens(data.tokens);\n    await exchange(data);\n    handleRedirect({ redirect, data });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}